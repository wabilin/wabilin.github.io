<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Wabilin's Blog]]></title><description><![CDATA[(∩ ◕_▩ )⊃━☆ Explosion!!]]></description><link>https://wabilin.github.io/</link><generator>RSS for Node</generator><lastBuildDate>Wed, 24 Jun 2020 16:42:43 GMT</lastBuildDate><atom:link href="https://wabilin.github.io/feed.xml" rel="self" type="application/rss+xml"/><pubDate>Wed, 24 Jun 2020 16:42:43 GMT</pubDate><language><![CDATA[zh-tw]]></language><managingEditor><![CDATA[Wabilin]]></managingEditor><webMaster><![CDATA[Wabilin]]></webMaster><category><![CDATA[Software Development]]></category><category><![CDATA[Japanese Otaku]]></category><item><title><![CDATA[Hello World 聖地巡禮 Part 2]]></title><description><![CDATA[
    <p>本來以為 HELLO WORLD 的聖地巡禮幾乎完成了。</p>
<p>BD 到貨之後重新整理了一下，發現點比原本想的還多。<br>
這次就先從劇情中重要的點開始吧！</p>
<p>本篇包含：上賀茂神社（續）、伏見稲荷大社、雙ヶ岡、朝霧橋、堀川高校</p>
<!-- more -->
<p>由於 BD 播放禁止截圖，動畫截圖是用手機拍電視... 品質請包涵<br>
另外由於大多是重看 BD 前就去的，拍照的構圖會和電影中的不太一樣</p>
<h2 id="上賀茂神社（續）">上賀茂神社（續）</h2>
<p>前篇請見: <a href="https://www.ptt.cc/bbs/C_Chat/M.1575812107.A.32C.html">https://www.ptt.cc/bbs/C_Chat/M.1575812107.A.32C.html</a></p>
<p>最近有京都朋友問我上賀茂神社和 HELLO WORLD 有什麼關係...</p>
<p>本來以為很好認的，看來還是要上個對照圖XD
<picture><source type="image/webp" srcset="https://wabilin.github.io/img/2020/05/movie/IMG_9118.webp"><source type="image/jpeg" srcset="https://wabilin.github.io/img/2020/05/movie/IMG_9118.jpg"><img src="https://wabilin.github.io/img/2020/05/movie/IMG_9118.jpg" alt="kamikamo-movieshot"></picture>
<picture><source type="image/webp" srcset="https://wabilin.github.io/img/2020/05/hello-real-world/IMG_2425.webp"><source type="image/jpeg" srcset="https://wabilin.github.io/img/2020/05/hello-real-world/IMG_2425.jpg"><img src="https://wabilin.github.io/img/2020/05/hello-real-world/IMG_2425.jpg" alt="kamikamo-real"></picture></p>
<p>造型確實做了一些改動，可能要比較迷神社的人才會一眼發現吧w</p>
<p>再去一次發現了崛口由紀子老師手繪的繪馬
<picture><source type="image/webp" srcset="https://wabilin.github.io/img/2020/05/hello-real-world/IMG_7180.webp"><source type="image/jpeg" srcset="https://wabilin.github.io/img/2020/05/hello-real-world/IMG_7180.jpg"><img src="https://wabilin.github.io/img/2020/05/hello-real-world/IMG_7180.jpg" alt="kamikamo-ema"></picture></p>
<p>春季非常推薦順便去附近的櫻花隧道走一走
<picture><source type="image/webp" srcset="https://wabilin.github.io/img/2020/05/hello-real-world/DSC03705.webp"><source type="image/jpeg" srcset="https://wabilin.github.io/img/2020/05/hello-real-world/DSC03705.JPG"><img src="https://wabilin.github.io/img/2020/05/hello-real-world/DSC03705.JPG" alt="kamikamo-sakura"></picture></p>
<h2 id="伏見稲荷大社">伏見稲荷大社</h2>
<p>交通方式: JR 伏見稲荷 / 京阪 伏見稲荷</p>
<p>電影中大小堅書第一次相遇的地點。<br>
全日本稲荷神社的總本神，以千本鳥居聞名於世...</p>
<p>所以平常擠滿了觀光客，但這次疫情的關係難得可以悠閒地參拜。</p>
<p><em>直実追著烏鴉來到大社的正門</em>
<picture><source type="image/webp" srcset="https://wabilin.github.io/img/2020/05/movie/IMG_9075.webp"><source type="image/jpeg" srcset="https://wabilin.github.io/img/2020/05/movie/IMG_9075.jpg"><img src="https://wabilin.github.io/img/2020/05/movie/IMG_9075.jpg" alt="fusimi-movieshot-1"></picture>
<picture><source type="image/webp" srcset="https://wabilin.github.io/img/2020/05/hello-real-world/DSC03926.webp"><source type="image/jpeg" srcset="https://wabilin.github.io/img/2020/05/hello-real-world/DSC03926.JPG"><img src="https://wabilin.github.io/img/2020/05/hello-real-world/DSC03926.JPG" alt="fusimi-real"></picture></p>
<p><em>站在千本鳥居的入口</em>
<picture><source type="image/webp" srcset="https://wabilin.github.io/img/2020/05/movie/IMG_9077.webp"><source type="image/jpeg" srcset="https://wabilin.github.io/img/2020/05/movie/IMG_9077.jpg"><img src="https://wabilin.github.io/img/2020/05/movie/IMG_9077.jpg" alt="fusimi-movieshot-2"></picture>
<picture><source type="image/webp" srcset="https://wabilin.github.io/img/2020/05/hello-real-world/DSC03966.webp"><source type="image/jpeg" srcset="https://wabilin.github.io/img/2020/05/hello-real-world/DSC03966.JPG"><img src="https://wabilin.github.io/img/2020/05/hello-real-world/DSC03966.JPG" alt="fusimi-real-2"></picture>
(外拍的人一直站在那邊，只好讓他們入鏡了)</p>
<p>千本鳥居真的很壯觀，雖然平常滿滿的人潮，很難看到這個景就是了（笑）
<picture><source type="image/webp" srcset="https://wabilin.github.io/img/2020/05/hello-real-world/DSC03971.webp"><source type="image/jpeg" srcset="https://wabilin.github.io/img/2020/05/hello-real-world/DSC03971.JPG"><img src="https://wabilin.github.io/img/2020/05/hello-real-world/DSC03971.JPG" alt="fusimi-real-3"></picture></p>
<p><em>在千本鳥居（大）看到剛進入成功的老師</em>
<picture><source type="image/webp" srcset="https://wabilin.github.io/img/2020/05/movie/IMG_9082.webp"><source type="image/jpeg" srcset="https://wabilin.github.io/img/2020/05/movie/IMG_9082.jpg"><img src="https://wabilin.github.io/img/2020/05/movie/IMG_9082.jpg" alt="fusimi-movieshot-3"></picture>
<picture><source type="image/webp" srcset="https://wabilin.github.io/img/2020/05/hello-real-world/DSC04007.webp"><source type="image/jpeg" srcset="https://wabilin.github.io/img/2020/05/hello-real-world/DSC04007.JPG"><img src="https://wabilin.github.io/img/2020/05/hello-real-world/DSC04007.JPG" alt="fusimi-real-3"></picture></p>
<p>從外部看是翠綠山林中綿延的鳥居
<picture><source type="image/webp" srcset="https://wabilin.github.io/img/2020/05/hello-real-world/DSC04016.webp"><source type="image/jpeg" srcset="https://wabilin.github.io/img/2020/05/hello-real-world/DSC04016.JPG"><img src="https://wabilin.github.io/img/2020/05/hello-real-world/DSC04016.JPG" alt="fusimi-real-4"></picture></p>
<h2 id="雙ヶ岡">雙ヶ岡</h2>
<p>交通方式: JR 花園</p>
<p><em>直実和老師每天朝練的地方</em></p>
<p>雖然寫「名勝」但是基本上幾乎沒有人會來的偏僻地方。<br>
山路幾乎沒有在維護的感覺，一個人來的時候很擔心出事會回不去，果然是個適合練功的地方w
<picture><source type="image/webp" srcset="https://wabilin.github.io/img/2020/05/movie/IMG_9095.webp"><source type="image/jpeg" srcset="https://wabilin.github.io/img/2020/05/movie/IMG_9095.jpg"><img src="https://wabilin.github.io/img/2020/05/movie/IMG_9095.jpg" alt="fusimi-movieshot-4"></picture>
<picture><source type="image/webp" srcset="https://wabilin.github.io/img/2020/05/hello-real-world/IMG_6567.webp"><source type="image/jpeg" srcset="https://wabilin.github.io/img/2020/05/hello-real-world/IMG_6567.jpg"><img src="https://wabilin.github.io/img/2020/05/hello-real-world/IMG_6567.jpg" alt="fusimi-real-5"></picture></p>
<p>原本有階梯的地方幾乎都破損殆盡了，少數地方還能看到階梯的殘骸
<picture><source type="image/webp" srcset="https://wabilin.github.io/img/2020/05/movie/IMG_9096.webp"><source type="image/jpeg" srcset="https://wabilin.github.io/img/2020/05/movie/IMG_9096.jpg"><img src="https://wabilin.github.io/img/2020/05/movie/IMG_9096.jpg" alt="fusimi-movieshot-4"></picture>
<picture><source type="image/webp" srcset="https://wabilin.github.io/img/2020/05/hello-real-world/IMG_6588.webp"><source type="image/jpeg" srcset="https://wabilin.github.io/img/2020/05/hello-real-world/IMG_6588.jpg"><img src="https://wabilin.github.io/img/2020/05/hello-real-world/IMG_6588.jpg" alt="fusimi-real-5"></picture>
<picture><source type="image/webp" srcset="https://wabilin.github.io/img/2020/05/hello-real-world/IMG_6612.webp"><source type="image/jpeg" srcset="https://wabilin.github.io/img/2020/05/hello-real-world/IMG_6612.jpg"><img src="https://wabilin.github.io/img/2020/05/hello-real-world/IMG_6612.jpg" alt="fusimi-real-6"></picture></p>
<p>電影中的練功場真的不好找，這次應該是沒找對，但氣氛蠻接近的。
<picture><source type="image/webp" srcset="https://wabilin.github.io/img/2020/05/movie/IMG_9097.webp"><source type="image/jpeg" srcset="https://wabilin.github.io/img/2020/05/movie/IMG_9097.jpg"><img src="https://wabilin.github.io/img/2020/05/movie/IMG_9097.jpg" alt="fusimi-movieshot-5"></picture>
<picture><source type="image/webp" srcset="https://wabilin.github.io/img/2020/05/hello-real-world/IMG_6634.webp"><source type="image/jpeg" srcset="https://wabilin.github.io/img/2020/05/hello-real-world/IMG_6634.jpg"><img src="https://wabilin.github.io/img/2020/05/hello-real-world/IMG_6634.jpg" alt="fusimi-real-7"></picture></p>
<p>鼓起勇氣攻頂了，景色一般般XD
<picture><source type="image/webp" srcset="https://wabilin.github.io/img/2020/05/hello-real-world/IMG_6596.webp"><source type="image/jpeg" srcset="https://wabilin.github.io/img/2020/05/hello-real-world/IMG_6596.jpg"><img src="https://wabilin.github.io/img/2020/05/hello-real-world/IMG_6596.jpg" alt="fusimi-real-8"></picture></p>
<h2 id="宇治朝霧橋">宇治朝霧橋</h2>
<p>交通方式: JR 宇治 / 京阪 宇治</p>
<p><em>夏季煙火大會，全片中最關鍵的劇情轉折處</em></p>
<p>從遠方看朝霧橋。
<picture><source type="image/webp" srcset="https://wabilin.github.io/img/2020/05/hello-real-world/DSC00496.webp"><source type="image/jpeg" srcset="https://wabilin.github.io/img/2020/05/hello-real-world/DSC00496.jpg"><img src="https://wabilin.github.io/img/2020/05/hello-real-world/DSC00496.jpg" alt="fusimi-real-9_1"></picture></p>
<p>京粉應該發現了，這裡也是《吹響吧！上低音號》的名場景所在 XD</p>
<p><picture><source type="image/webp" srcset="https://wabilin.github.io/img/2020/05/hello-real-world/DSC00480.webp"><source type="image/jpeg" srcset="https://wabilin.github.io/img/2020/05/hello-real-world/DSC00480.jpg"><img src="https://wabilin.github.io/img/2020/05/hello-real-world/DSC00480.jpg" alt="fusimi-real-9_1"></picture>
<picture><source type="image/webp" srcset="https://wabilin.github.io/img/2020/05/hello-real-world/DSC00482.webp"><source type="image/jpeg" srcset="https://wabilin.github.io/img/2020/05/hello-real-world/DSC00482.jpg"><img src="https://wabilin.github.io/img/2020/05/hello-real-world/DSC00482.jpg" alt="fusimi-real-9_1"></picture></p>
<p>由於這裡是京阿尼的地盤，附近也可以看到不少京都動畫人物的『飛び出し注意』立牌。</p>
<p>觀光中心也有擺出 HELLO WORLD 的立牌！ <br>
背後有上低音號的海報，兩個願望一次滿足！
<picture><source type="image/webp" srcset="https://wabilin.github.io/img/2020/05/hello-real-world/IMG_6907.webp"><source type="image/jpeg" srcset="https://wabilin.github.io/img/2020/05/hello-real-world/IMG_6907.jpg"><img src="https://wabilin.github.io/img/2020/05/hello-real-world/IMG_6907.jpg" alt="fusimi-real-9_1"></picture></p>
<p>亂晃了一會，終於來到朝霧橋，真的好美。 <br>
動畫中的夏季煙火大會，現實中已經因為安全因素停辦了。希望有一天會再開QQ
<picture><source type="image/webp" srcset="https://wabilin.github.io/img/2020/05/movie/IMG_9112.webp"><source type="image/jpeg" srcset="https://wabilin.github.io/img/2020/05/movie/IMG_9112.jpg"><img src="https://wabilin.github.io/img/2020/05/movie/IMG_9112.jpg" alt="fusimi-movieshot-6"></picture>
<picture><source type="image/webp" srcset="https://wabilin.github.io/img/2020/05/movie/IMG_9113.webp"><source type="image/jpeg" srcset="https://wabilin.github.io/img/2020/05/movie/IMG_9113.jpg"><img src="https://wabilin.github.io/img/2020/05/movie/IMG_9113.jpg" alt="fusimi-movieshot-7"></picture>
<picture><source type="image/webp" srcset="https://wabilin.github.io/img/2020/05/hello-real-world/DSC00520.webp"><source type="image/jpeg" srcset="https://wabilin.github.io/img/2020/05/hello-real-world/DSC00520.jpg"><img src="https://wabilin.github.io/img/2020/05/hello-real-world/DSC00520.jpg" alt="fusimi-real-9"></picture></p>
<p><em>直実跌落樓梯QQ</em>
<picture><source type="image/webp" srcset="https://wabilin.github.io/img/2020/05/movie/IMG_9116.webp"><source type="image/jpeg" srcset="https://wabilin.github.io/img/2020/05/movie/IMG_9116.jpg"><img src="https://wabilin.github.io/img/2020/05/movie/IMG_9116.jpg" alt="fusimi-movieshot-7"></picture>
<picture><source type="image/webp" srcset="https://wabilin.github.io/img/2020/05/hello-real-world/DSC00531.webp"><source type="image/jpeg" srcset="https://wabilin.github.io/img/2020/05/hello-real-world/DSC00531.jpg"><img src="https://wabilin.github.io/img/2020/05/hello-real-world/DSC00531.jpg" alt="fusimi-real-10"></picture></p>
<p>雖然影片中場景在朝霧橋，但是作為電影海報場景的應該是旁邊的喜撰橋 [1]
<picture><source type="image/webp" srcset="https://wabilin.github.io/img/2020/05/movie/ogp_img2.webp"><source type="image/jpeg" srcset="https://wabilin.github.io/img/2020/05/movie/ogp_img2.jpg"><img src="https://wabilin.github.io/img/2020/05/movie/ogp_img2.jpg" alt="fusimi-movieshot-poster"></picture></p>
<p><picture><source type="image/webp" srcset="https://wabilin.github.io/img/2020/05/hello-real-world/DSC00566.webp"><source type="image/jpeg" srcset="https://wabilin.github.io/img/2020/05/hello-real-world/DSC00566.jpg"><img src="https://wabilin.github.io/img/2020/05/hello-real-world/DSC00566.jpg" alt="fusimi-real-8"></picture>
<picture><source type="image/webp" srcset="https://wabilin.github.io/img/2020/05/hello-real-world/DSC00568.webp"><source type="image/jpeg" srcset="https://wabilin.github.io/img/2020/05/hello-real-world/DSC00568.jpg"><img src="https://wabilin.github.io/img/2020/05/hello-real-world/DSC00568.jpg" alt="fusimi-real-8"></picture></p>
<p>又順便逛到了隔壁棚的名場景: 久美子的椅子
<picture><source type="image/webp" srcset="https://wabilin.github.io/img/2020/05/hello-real-world/IMG_6910.webp"><source type="image/jpeg" srcset="https://wabilin.github.io/img/2020/05/hello-real-world/IMG_6910.jpg"><img src="https://wabilin.github.io/img/2020/05/hello-real-world/IMG_6910.jpg" alt="fusimi-real-8"></picture></p>
<p>稍微爬了一下山，又一個久美子和麗奈的名場景
<picture><source type="image/webp" srcset="https://wabilin.github.io/img/2020/05/hello-real-world/DSC00649.webp"><source type="image/jpeg" srcset="https://wabilin.github.io/img/2020/05/hello-real-world/DSC00649.jpg"><img src="https://wabilin.github.io/img/2020/05/hello-real-world/DSC00649.jpg" alt="fusimi-real-8"></picture></p>
<p>宇治一帶雖然也是觀光地，相較於京都內的觀光勝地比較沒這麼擁擠。</p>
<p>同時也是由於同時也是京阿尼的總本山，非常推薦來一逛！</p>
<h2 id="堀川高校">堀川高校</h2>
<p>動畫中錦高校，實際取材自堀川高校。</p>
<p>附近也是本能寺之亂的本能寺遺跡 <em>（真是火事頻發的地方啊...）</em></p>
<p>喜歡戰國史的人必來... 話雖如此，實際上真的只剩下一個碑。
<picture><source type="image/webp" srcset="https://wabilin.github.io/img/2020/05/hello-real-world/IMG_6645.webp"><source type="image/jpeg" srcset="https://wabilin.github.io/img/2020/05/hello-real-world/IMG_6645.jpg"><img src="https://wabilin.github.io/img/2020/05/hello-real-world/IMG_6645.jpg" alt="fusimi-real-8"></picture></p>
<p><picture><source type="image/webp" srcset="https://wabilin.github.io/img/2020/05/movie/IMG_9100.webp"><source type="image/jpeg" srcset="https://wabilin.github.io/img/2020/05/movie/IMG_9100.jpg"><img src="https://wabilin.github.io/img/2020/05/movie/IMG_9100.jpg" alt="fusimi-movieshot-7"></picture>
<picture><source type="image/webp" srcset="https://wabilin.github.io/img/2020/05/hello-real-world/IMG_6643.webp"><source type="image/jpeg" srcset="https://wabilin.github.io/img/2020/05/hello-real-world/IMG_6643.jpg"><img src="https://wabilin.github.io/img/2020/05/hello-real-world/IMG_6643.jpg" alt="fusimi-real-8"></picture></p>
<p>這裡放置了大家收集來的二手書
<picture><source type="image/webp" srcset="https://wabilin.github.io/img/2020/05/movie/IMG_9106.webp"><source type="image/jpeg" srcset="https://wabilin.github.io/img/2020/05/movie/IMG_9106.jpg"><img src="https://wabilin.github.io/img/2020/05/movie/IMG_9106.jpg" alt="fusimi-movieshot-7"></picture>
<picture><source type="image/webp" srcset="https://wabilin.github.io/img/2020/05/movie/IMG_9107.webp"><source type="image/jpeg" srcset="https://wabilin.github.io/img/2020/05/movie/IMG_9107.jpg"><img src="https://wabilin.github.io/img/2020/05/movie/IMG_9107.jpg" alt="fusimi-movieshot-7"></picture></p>
<p><picture><source type="image/webp" srcset="https://wabilin.github.io/img/2020/05/hello-real-world/IMG_6654.webp"><source type="image/jpeg" srcset="https://wabilin.github.io/img/2020/05/hello-real-world/IMG_6654.jpg"><img src="https://wabilin.github.io/img/2020/05/hello-real-world/IMG_6654.jpg" alt="fusimi-real-8"></picture>
巡禮到這個點心中一陣QQ...</p>
<hr>
<p>Part 2 就先到這裡。</p>
<p>目前還剩下的點:<br>
京都車站、南圖書館、北圖書館、京阪伏見稲荷站、地下鉄二条駅、京都府廳、出町柳、出町柳駅前、北園公車站、堀川蛸薬師公車站、東寺、JR宇治駅、京都大学、四条烏丸、五条堀川大橋、本願寺、中央郵便局、京都塔</p>
<p>真是可怕的多啊XD，期待自己能在兩個月之內完成。</p>
<p>預計跑完一次之後會再製作地圖和參觀建議，畢竟以海外觀光來說這麼多點，不做取捨的話很難規劃行程吧。<br>
也希望疫情早日平定，讓大家都能來巡禮一回。</p>
<p>[1]: 圖片來源: 官方網站 <a href="https://hello-world-movie.com/">https://hello-world-movie.com/</a></p>

  ]]></description><link>https://wabilin.github.io/2020-05-31-hello-world-2.html</link><guid isPermaLink="true">https://wabilin.github.io/2020-05-31-hello-world-2.html</guid><pubDate>Sun, 31 May 2020 00:00:00 GMT</pubDate></item><item><title><![CDATA[Spacemacs - 人生最佳的編輯器體驗]]></title><description><![CDATA[
    <p><em>這不是一篇信仰文，這是篇在編輯器的深淵中終於拉到一條繩子文。</em></p>
<p>開始使用 <a href="http://spacemacs.org/">Spacemacs</a> 兩個星期，我可以說這是我用過最喜歡的文字編輯器。
他結合了編輯器大戰的兩巨頭 vim 與 emacs 的操作方式，在入門上卻「<strong>親民</strong>」許多。</p>
<p>如果曾經(或正在** vim 或 emacs 上遭受挫折，卻又嚮往他們的某些優點，不妨一試 Spacemacs 。</p>
<p>簡單說，他是一個：<strong>裝了 vim 又裝了一堆超實用功能又全部設定得又完整又有邏輯的 emacs</strong></p>
<p><strong>使用 Spacemacs 你只需要會一些 vim 或 emacs 的基本操作，其他較進階的功能則無須特別記憶或設定。</strong></p>
<!-- more -->

<p>vim 和 emacs 我都有過些許的使用經驗。
「親民」實在很難當作二者的標榜，大多時候勸誘新手的說法是：「嘿，這個你熟悉了就會超強超快啦～」
（然後老手開始表演各種魔術般的飛快操作）</p>
<p>我可以理解熟悉了 vim (或 emacs) 之後那種愉快的操作感，讓老手們說出這樣的話是很合理的。
但跨不過門檻（大量快速鍵記憶、設定檔調教...）而中途放棄者還是大有人在。</p>
<p>身為一個 vim &amp; emacs 菜鳥，我認為作為編輯器的效率是真的很棒，但還是有一些缺點（尤其是對新手）：</p>
<ol>
<li>設定調教略為麻煩</li>
<li>太多快速鍵(特別在裝了大插件後)，又缺乏能系統性記憶的方式</li>
</ol>
<p>我在用 vim 的第一天就有了一整頁的 <code>.vimrc</code> ，在三個月後又長了五倍大。雖然試圖努力精簡整理，但後來也是越長越肥。
而在裝了一些插件之後，把功能設到一些「自己覺得好按」的位置上之後，再下一個插件又要想該給哪些位置。</p>
<p>然而這些自己不斷長出來的設定，當初並沒有審慎的規劃設計，只是個人養成的(或抄來的)習慣而已。
到後來一些使用頻率次要的功能就容易忘記要按啥了。</p>
<p>至於 Spacemacs 呢? 很不可思議的，我使用到現在 <strong>加過的設定不到10行。真正重要的只有兩行</strong> 用起來已經比我調了許久的 vim 還要順手了。</p>
<h3 id="小優點：混合式的操作模式">小優點：混合式的操作模式</h3>
<p>Spacemacs 對外掛功能的整合和富邏輯性的按鍵配置，本篇後面會詳細說明。</p>
<p>先提一個我覺得很棒的小優勢： <strong>在 Spacemacs 可以混和 vim 和 emacs 的操作方式！</strong></p>
<p>雖然雙方陣營可能都認為己方才是真理，但我自己是覺得各有好用的地方，能混著用除了 <em>信仰不夠純正</em> 之外實在沒什麼壞處。
我從大部分的操作方式偏好 vim ，但有時候就會懷念起 emacs 的按法。</p>
<p>舉個最常見的操作：在 <code>insert mode</code> 中存檔，再回到 <code>insert mode</code> 繼續編輯。</p>
<ul>
<li>vim: <code>C-[ : w Enter i</code> (別忘了 <code>:</code> 實際上是 <code>Shift-;</code>)</li>
<li>emacs: <code>C-x C-s</code></li>
</ul>
<p>emacs 的按法明顯輕鬆許多，所以我存檔的時候都會使用 emacs 的按法。另外常見的好處還有想在 <code>insert mode</code> 中移動游標又懶得回 <code>normal mode</code> ，我也是直接按 emacs 的快速鍵。</p>
<h3 id="腦袋清楚了：這個按鍵配置真的很神">腦袋清楚了：這個按鍵配置真的很神</h3>
<p>在 Spacemacs 中，所有次要（上下左右等等以外）的功能，都是由 <code>空白鍵</code> 這個 leader key 作為起點。（所以叫 spacemacs）</p>
<p>當然 leader key 不是 spacemacs 的發明，但把他把這之後的按鍵路徑配得非常有系統。絕大多數的按鍵操作會是這樣：</p>
<p><code>Space</code> (開始) -&gt; 分類 -&gt; 功能</p>
<p>舉例來說</p>
<ol>
<li>如果我要打開專案(Project)中的檔案(File)，我就會按 <code>Space p f</code></li>
<li>如果我要打開專案(Project)的樹狀結構(Tree)，就會按 <code>Space p t</code></li>
<li>如果要查看 Git 的 Status，就是 <code>Space g s</code></li>
<li>如果要開啟 Git Blame 功能，就是 <code>Space g b</code></li>
</ol>
<p>這樣的按鍵規劃，讓人非常快速就可以上手，而且不容易忘記。</p>
<p>如果真的想不起來... 其實在按每個按鍵的時候下面都有提示可以偷看：
<picture><source type="image/webp" srcset="https://wabilin.github.io/img/2018/01/emacs_2_weeks/1.webp"><source type="image/jpeg" srcset="https://wabilin.github.io/img/2018/01/emacs_2_weeks/1.jpg"><img src="https://wabilin.github.io/img/2018/01/emacs_2_weeks/1.jpg" alt="SPC-p hint"></picture></p>
<p>如果這樣還找不到功能，也可以用 <code>Space ?</code> 或 <code>Space Space</code> 來搜尋</p>
<p>例如想要找 replace 功能:
<picture><source type="image/webp" srcset="https://wabilin.github.io/img/2018/01/emacs_2_weeks/2.webp"><source type="image/jpeg" srcset="https://wabilin.github.io/img/2018/01/emacs_2_weeks/2.jpg"><img src="https://wabilin.github.io/img/2018/01/emacs_2_weeks/2.jpg" alt="SPC-? hint"></picture></p>
<p>最糟狀況這樣都還找不到的話，也很容易 Google 得到。Spacemacs 的社群已經蠻大的了。</p>
<h3 id="怕：會不會習慣的-vim-功能在-spacemacs-沒有">怕：會不會習慣的 vim 功能在 Spacemacs 沒有?</h3>
<p>基本操作(hjkl / visual mode ...) 幾乎感覺不出來和 vim 的差別。</p>
<p>至於 vim 上面最實用最受歡迎的插件，大部分也都有對應的功能了。</p>
<p>舉我個人在 vim 上常使用的： FZF 、NERD Tree、YouCompleteMe、easymotion、fugitive 等等，
在 Spacemacs 上都有內建相似的功能，有些甚至更好用。</p>
<p>我目前在公司開發 Rails &amp; React.js 就是使用 Spacemacs，基本上沒有什麼不便。
應該是花錢(RubyMine) 以外試過做棒的環境了。(其他編輯器的 vim mode 還是不夠順手)</p>
<p>想知道對程式語言的支援或其他功能也可以查看 <a href="https://github.com/syl20bnr/spacemacs/tree/master/layers">Layers</a>，如果想要用 Emacs 收 Email 和 Slack 的話也行 :)</p>
<p>順帶一提，我以前最常用 Emacs 做的事情是玩貪食蛇XD</p>
<h3 id="一些，真的只有一些設定和提醒">一些，真的只有一些設定和提醒</h3>
<ol>
<li>Spacemacs 可以在 console 中正常使用，不過視窗版本體驗又更棒更豐富。</li>
<li>vim 在按 w 時，一個 word 是包含底線的，這點和 emacs 的預設不同，可以加一行設定: <code>(add-hook 'prog-mode-hook #'(lambda () (modify-syntax-entry ?_ "w")))</code></li>
<li>如果系統沒有裝其他搜尋工具的話，會使用 <code>grep</code> 搜尋，速度有點慢，建議安裝一下 <a href="https://github.com/ggreer/the_silver_searcher">ag</a></li>
<li>絕大部分的設定和套件安裝都是編輯 dotfile ，請按 <code>Space f e d</code> 打開設定。</li>
<li>字型、配色也都可以按個人喜好設定，關於主題設定可以參考<a href="https://emacs.stackexchange.com/questions/24958/how-install-a-custom-theme-to-spacemacs">這裡</a></li>
<li>可以在首頁更新所有 Package，別怕更新後壞掉，因為也可以直接在首頁還原(Rollback)上次的更新。</li>
<li>如果是 VIM 使用者想上軌道，可以參考官方對 VIM USER 的入門文件 <a href="http://spacemacs.org/doc/VIMUSERS.html">http://spacemacs.org/doc/VIMUSERS.html</a></li>
<li>當你按錯鍵想取消，按 <code>Ctrl-g</code> 就對了</li>
</ol>
<h3 id="推薦的實用功能">推薦的實用功能</h3>
<ol>
<li><a href="https://github.com/magit/magit">magit</a>: 在安裝 git layer 後， <code>Space g</code> 開啟。我曾經試過許多 git 工具，這是少數真的可以讓人幾乎不用回到 console 下 git command 的。</li>
<li>類似 easymotion: 按下 <code>Space j j</code> 搜尋字母快速跳躍、<code>Space j l</code> 快速跳行。</li>
<li>分割視窗、在視窗間移動 <code>Space w</code>。 在 buffer(可以想成tab) 間移動 <code>Space b b</code>，快速切到上個 buffer <code>Space TAB</code> 。</li>
<li>想要裝什麼功能，按 <code>Space f e d</code> 找 <code>dotspacemacs-configuration-layers</code> 就可以了。</li>
</ol>

  ]]></description><link>https://wabilin.github.io/2018-01-20-spacemacs-2-weeks.html</link><guid isPermaLink="true">https://wabilin.github.io/2018-01-20-spacemacs-2-weeks.html</guid><pubDate>Sat, 20 Jan 2018 00:00:00 GMT</pubDate></item><item><title><![CDATA[C++ 掃雷記：字串加上整數?]]></title><description><![CDATA[
    <p>本篇來自一年多前維護專案時看到的一段程式碼：</p>
<pre><code class="language-cpp">for (int i = 0; i &lt; count; i++) {
  MyObject obj;
  obj.set_unique_name(name + i);
  objs.push_back(obj);
}</code></pre>
<!-- more -->

<p>假如 <code>name</code> 是 <code>"John"</code>，我們預期這會產生名稱分別為 <code>John1</code>, <code>John2</code>, <code>John3</code>...的物件。</p>
<p>做為同時會寫 JavaScript 等語言的人，在 trace 這段程式的時候，第一時間真的不覺得有什麼不對。</p>
<p>畢竟他看起來很自然。就語法來說， <code>std::string</code> 定義了 <code>operator+(int)</code> 也不是什麼太奇怪的事。</p>
<p><strong>事實上並沒有。</strong></p>
<p>如果你這麼做是會噴 error 的：</p>
<pre><code class="language-cpp">string s = "string";
s + 1;

// error: invalid operands to binary expression ('string' (aka 'basic_string&lt;char,
//      char_traits&lt;char&gt;, allocator&lt;char&gt; &gt;') and 'int')</code></pre>
<p>很奇妙的，原例中的那段程式碼卻沒有 error，甚至沒有 warning。</p>
<p>於是我又跑回去看。</p>
<pre><code class="language-cpp">char* name = "John";</code></pre>
<p>哇！沒想到在這個情境還有人使用 <code>char*</code> 而非 <code>std::string</code>呀！</p>
<p>於是程式的行為也會變得很有趣，對 C 語言指標有所了解的應該會知道，程式跑起來大概會變這樣：</p>
<pre><code class="language-cpp">name + 0; //=&gt; John
name + 1; //=&gt; ohn
name + 2; //=&gt; hn</code></pre>
<p>這無疑是個可笑的 bug。當這段程式出現在一個考題中，相信大部分的人都可以發現其錯誤之處。
但當他是一段專案中的程式碼，卻很可能不被注意到。</p>
<p>所以我特別當成一段趣事記錄下來。下次再看到有人對字串做加法請多加注意。然後拜託非必要別在 C++ 中使用 <code>char*</code> 哇。</p>

  ]]></description><link>https://wabilin.github.io/2017-09-16-cpp-string-plus.html</link><guid isPermaLink="true">https://wabilin.github.io/2017-09-16-cpp-string-plus.html</guid><pubDate>Sat, 16 Sep 2017 00:00:00 GMT</pubDate></item><item><title><![CDATA[幫 Jekyll Blog 加上 Tags 功能 (GitHub Pages 可用)]]></title><description><![CDATA[
    <p>為了在 Jekyll Blog 上使用 tags 的功能，我花了些力氣研究。
雖然有現成的 plugin 可以用，但為了能讓 GitHub Pages 跑，那些 plugin 就不太可用了。</p>
<p>這篇是我目前找出來最為方便的方法。</p>
<!-- more -->

<p>首先在每個 post 的檔案上方，要用像這樣的方式加入 tag</p>
<pre><code class="language-yaml">---
layout: post
title: 幫 Jekyll Blog 加上 Tags 功能
tags: jekyll
license: cc0
---</code></pre>
<p>我在首頁加入這一段程式：</p>
<script src="https://gist.github.com/wabilin/99589a0e71f15fd17a5699de97387ba4.js"></script>

<p>這段程式會找出所有網站中使用過的 tag，並幫他做出一個到 <code>/tag_indices/tag-name</code>的連結。</p>
<p><code>tag_indices</code> 是一個我自定資料夾路徑。我希望每個裡面 tag name 路徑都能列出與該 tag 相關的文章。</p>
<p>所以我先幫他們製作了應有的 layout</p>
<script src="https://gist.github.com/wabilin/de1b5ab47d12e29c650ff12b8a870c40.js"></script>

<p>這個 layout 會認該頁面的標題(<code>page.title</code>)，然後從全站的文章中找出文章 tag 名稱與本頁標題相同的文章。變成一串列表顯示出來。</p>
<p>但是 Jekyll 沒有聰明到自動幫我們從每篇文章的 tag 去產生出相應的 tag 目錄。</p>
<p>我查到某些資料做法是：手動新增。</p>
<p>也就是說，如果新增了一個含有 <code>example</code> tag 的文章，就要新增一個 <code>/tag_indices/example/index.md</code> 檔案，並加入內容：</p>
<pre><code class="language-yaml">---
layout: tag_index
title: example
---</code></pre>
<p>在 Jeklly 讀到這個檔案的時候，就會去找所有含有 <code>example</code> tag 的文章，生成目錄。</p>
<p>懶惰如我當然不可能每次加新標籤都去手動創一個檔案。所以我寫了下面這個很隨便的 ruby script 來幫我自動產生這些 tag 目錄：</p>
<pre><code class="language-rb"># DO make sure ur post have tags attr, split tag names by space
require 'set'

def main()
  tag_set = collect_tags('./_posts/')
  puts "Your tags are: #{tag_set.to_a.to_s}"

  tag_root_path = './tag_indices/'
  create_tag_files(tag_set, tag_root_path)
end

def collect_tags(post_dir_path)
  tag_set = Set.new

  Dir.foreach(post_dir_path) do |post|
    next if post == '.' || post == '..' || post == '.gitkeep'
    file_path = post_dir_path + post
    puts file_path
    File.open(file_path, 'r') do |infile|
      while (line = infile.gets)
        if line.start_with?('tags:')
          puts line
          _, *tags = line.split(/\s/)
          tag_set.merge(tags)
        end
      end
    end
  end

  return tag_set
end

def create_tag_files(tags, tag_root_path)
  tags.each do |tag|
    tag_path = tag_root_path + tag
    if Dir.exist?(tag_path)
      puts "#{tag_path} exist. skip."
    else
      mkdir_ok = system('mkdir', '-p', tag_path)
      unless mkdir_ok
        puts "Failed when creating dir #{tag_path}"
        exit(1)
      end
      create_md_file(tag, "#{tag_path}/index.md")
    end
  end
end

def create_md_file(tag, path)
  File.open(path, 'w') do |file|
    file.puts('---')
    file.puts('layout: tag_index')
    file.puts("title: #{tag}")
    file.puts('---')
  end
end

main()</code></pre>
<p>有需要的話可以直接拿去用，不過注意我這裡假定 tags 屬性都是些用空白分隔的單字。</p>
<ul>
<li>參考資料: <a href="http://vvv.tobiassjosten.net/jekyll/jekyll-tag-cloud/">http://vvv.tobiassjosten.net/jekyll/jekyll-tag-cloud/</a></li>
</ul>

  ]]></description><link>https://wabilin.github.io/2017-09-15-jekyll-tags.html</link><guid isPermaLink="true">https://wabilin.github.io/2017-09-15-jekyll-tags.html</guid><pubDate>Fri, 15 Sep 2017 00:00:00 GMT</pubDate></item><item><title><![CDATA[[Ruby] Yield 筆記]]></title><description><![CDATA[
    <p>關於 <code>yield</code> 這個關鍵字，我剛學 Ruby 的時候逃避了。</p>
<p>現在重看一次，發現其實不是什麼太困難的東西。</p>
<p>簡單說， 就是一個執行之後使用者自訂 block 的語法。</p>
<!-- more -->
<p>用一個例子把做法記起來最快：</p>
<pre><code class="language-rb">def foo
  val = 1
  yield val
end

foo { |x| puts x }
# =&gt; 1</code></pre>
<p>可以發現在 <code>yield</code> 的部分把 block 掛進去了。
事實上這兩種寫法意義是差不多的：</p>
<pre><code class="language-rb">def foo
  val = 1
  yield val
end

def foo2(&amp;block)
  val = 2
  block.call(val)
end

foo { |x| puts x }
foo2 { |x| puts x }

# =&gt; 1
# =&gt; 2</code></pre>
<p>我個人更喜歡 <code>foo2</code> 那樣明確的寫法，一目瞭然，新手老手都看得懂。</p>
<p>然而參與 Ruby 相關專案，一定還是得了解 <code>yield</code> 該如何使用，畢竟很多 Ruby 人偏好看起來簡短的做法。</p>
<p>了解怎麼用 <code>yield</code> 和 block 以後，也就可以了解一些 Ruby 慣用做法的製造方式了。</p>
<p>例如最常用的 <code>each</code> 方法，現在也可以試著自己寫一個：</p>
<pre><code class="language-rb">class MyArray
  def initialize(src_ary)
    @ary = src_ary.clone
  end

  def each
    @ary.each do |x|
      yield x
    end
  end
end

my_array = MyArray.new([1, 2, 3])
my_array.each { |ele| puts 2 * ele }

# =&gt; 2
# =&gt; 4
# =&gt; 6</code></pre>
<p>簡單吧 :)</p>

  ]]></description><link>https://wabilin.github.io/2017-09-05-ruby-yield.html</link><guid isPermaLink="true">https://wabilin.github.io/2017-09-05-ruby-yield.html</guid><pubDate>Tue, 05 Sep 2017 00:00:00 GMT</pubDate></item><item><title><![CDATA[在 Windows 使用 PS4 搖桿進行遊戲]]></title><description><![CDATA[
    <p>在 Windows 最理想的遊戲手把應該還是 xBox One 的手把，
但是實在沒錢多買一個啊XD</p>
<!-- more -->
<p>好在 PC 上其實也可以用 PS 搖桿，而 PS4 相較於 PS3 的設定又簡單許多了</p>
<p>好像 DS4 原本就有部分對 Windows 支援, 插上電腦會抓到。
但是要完美模擬 XBox 搖桿還是要裝一下軟體。</p>
<p>只要兩步驟輕鬆完成 :</p>
<ol>
<li>把 PS4 搖桿用 USB 線接上電腦</li>
<li>下載執行 <strong>DS4Windows</strong></li>
</ol>
<p>完工</p>
<ul>
<li>DS4Windows 官網 : <a href="http://ds4windows.com/">http://ds4windows.com/</a></li>
<li>Github : <a href="https://github.com/Jays2Kings/DS4Windows">https://github.com/Jays2Kings/DS4Windows</a></li>
</ul>
<p>測試環境: Windows 10 64bit</p>
<p>遊戲:</p>
<ol>
<li>Middle-earth™: Shadow of Mordor™</li>
<li>Grim Dawn</li>
</ol>

  ]]></description><link>https://wabilin.github.io/2016-03-01-windows-ps4-controller.html</link><guid isPermaLink="true">https://wabilin.github.io/2016-03-01-windows-ps4-controller.html</guid><pubDate>Tue, 01 Mar 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Dart 語言設計上的問題: Boolean Type]]></title><description><![CDATA[
    <p><a href="https://www.dartlang.org/">Dart</a> 是一個由 Google 開發，用來寫 web app 的程式語言。 做的基本上是現在通常用 JavaScript 來做的事情。 JavaScript 本身有很多設計上的缺陷，所以我也期待有一個這樣的新語言，能夠替代原本的 JavaScript，但是稍微看了一下，卻發現 Dart 本身也有些詭異的地方。</p>
<!-- more -->

<p>這篇來談一下 Dart 對於 Boolean 的設計問題。</p>
<p>我認為 Dart 對於布林值的型別轉換是很詭異的：</p>
<p>引自<a href="https://www.dartlang.org/docs/dart-up-and-running/">Dart: Up and Running</a></p>
<blockquote>
<p>When Dart expects a boolean value, only the value true is treated as true. All other values are treated as false. Unlike in JavaScript, values such as 1, “aString”, and someObject are all treated as false.</p>
</blockquote>
<p>這對於來自 JavaScript 的 programmer 來說真的是非常詭異(不幸的是，Dart語言的對象應該大多是原本的JS使用者) 舉例來說：</p>
<pre><code class="language-js">var name = 'Bob';
if (name) {
  print('You have a name!'); // Prints in JavaScript, not in Dart.
}</code></pre>
<p>在 JavaScript 中，會被當成 <code>false</code> 看待的值有： <code>false</code>, <code>0</code>, <code>null</code>, <code>NaN</code>, <code>undefined</code>, <code>""</code>(空字串) 這樣的設計雖然不能說很完美，但至少有一定的邏輯可以理解。 但是 Dart 的邏輯，至少我就無法理解了： <strong>為什麼一個不是空字串的字串會被轉換成 false?</strong></p>
<p>他們的說法是 <strong>“所有 true 以外的東西都是 false”</strong> ，看起來簡單明瞭，但是合理嗎?</p>
<p>比如說一個字串 <code>"true"</code>, 一個陣列<code>["Array"]</code>, 都是 false，我覺得很難說得通。 尤其是對於有大量接觸其他語言經驗的人，這看起來實在很詭異。</p>
<p>就列一下一些其他語言對 true/false 的看法(大多是從王垠的G+抄過來的:P)：</p>
<pre><code>Smalltalk: True is an object which contains a method named ‘ifTrue’.
Lisp: True is everything except nil.
Scheme: True is everything except #f .
Python: True is everything except 0, empty list, None, or …
Ruby: True is everything except nil and false.
Lua: True is everything except false and nil.
Icon: True is executed successfully.
sh: Exit status 0 is true, and every other exit status is false.</code></pre>
<pre><code>C/C++: True is everything except 0.
Haskell: True is True.
ML: True is true.
Java: True is true.
C#: True is true.
Go: True is true.</code></pre>
<p>敏銳的人應該已經知道這個表分隔的意義了。 很顯然的，Dart的作法是和下半部的大多語言一樣: <strong>True is true.</strong></p>
<p>那問題在哪裡? 問題可大著了：表下半部列的都是 <strong>static typing</strong> 的語言 而且除了 C/C++ 以外，都是 <strong>strong typing</strong> 的</p>
<p>這些語言可以在 <strong>編譯時期</strong> 就檢查出所有變數的類型，而且其他型別 <strong>不會</strong> 被隱式轉換成布林型別</p>
<p>以 Java 為例:</p>
<pre><code class="language-java">int i = 0;
if (i) {
  DoSomeThing();
}</code></pre>
<p>這段程式就不會通過編譯，因為你不可以把一個整數當做布林值來用，你必須這樣寫:</p>
<pre><code class="language-java">int i = 0;
if (i != 0) {
  DoSomeThing();
}</code></pre>
<p>也就是說當你要把某些東西當作布林來用(放在 if/while.. 的條件裡)，你必須自己把他轉換成布林值。</p>
<p>這個想法我是贊同的，但 Dart 也想用這個概念的時候就很尷尬了，因為 Dart 本身不是一個純的靜態型別語言。 在 Dart 可以宣告靜態型別的變數，也可以(甚至是官方建議) 使用動態型別。</p>
<p>像這樣:</p>
<pre><code class="language-js">int i = 0;
var b = true;
b = "A String";

if (i) { DoSomething(); }
if (b) { DoSomething(); }</code></pre>
<p>第一個 <code>if(i)</code> 可以在執行前就被檢查出錯誤，就像 Java 那樣 但第二個 <code>if(b)</code> 只有在執行到的時候才能確定 <code>b</code> 的型別 (注意 Dart 的 <code>var</code> 意義和 JavaScript 的 <code>var</code> 比較接近，是宣告一個動態型別的變數， 而不是像 C#. Golang 的 <code>var</code> 或 C++11 的 <code>auto</code> 在編譯時期推導並綁定型別)</p>
<p>這讓 Dart 的作法非常尷尬，回到上面的例子：</p>
<pre><code class="language-js">var name = 'Bob';
if (name) {
  print('You have a name!'); // Prints in JavaScript, not in Dart.
}</code></pre>
<blockquote>
<p>in Dart running in production mode, the above doesn’t print at all because name is converted to false (because name != true). In Dart running in checked mode, the above code throws an exception because the name variable is not a bool.</p>
</blockquote>
<p>意即，Dart 在 <strong>checked mode</strong> ， <strong>執行到</strong> 這段程式時會丟出例外，而在 production mode 則是把所有 <code>true</code> 以外的值都當成 <code>false</code>。</p>
<p>我的解釋是這樣：Dart 認為只有 Boolean 應該被當成 Boolean 來用(就像 Java 那樣)， <strong>但是依賴的卻是非常不可靠的檢查機制。</strong></p>
<p>為什麼不可靠?</p>
<ol>
<li>這行程式很可能在測試時跑 100 回都不會被跑到</li>
<li>許多 wep app 的開發者，不會做很嚴謹的測試</li>
</ol>
<p>所以說，這玩意與其說是檢查機制，不如說是放個牌子在那裏，讓 Programmer 在學習語言的時候稍微記憶下， <strong>盡量</strong> 提醒自己在寫程式的時候，不要把 boolean 以外的東西拿去當 boolean 用</p>
<p>但又回來這個問題了：多數 Dart 使用者可能是從 JavaScript 那裡來的 (笑</p>
<p>回到根本，有三個問題：</p>
<ol>
<li><p>Dart 提供的檢查機制太薄弱。現在有些工具甚至可以分析動態語言(如 Python. Ruby) 程式碼中的型別問題，但由於這些語言還有其他複雜的問題，很難 100% 的檢查出來。 但 Dart 作為一個 2011 年誕生的語言，如果在設計上多用點心思，其實很有可能做到同時使用動態型別和高強度的執行前型別檢查，而 Dart 至少目前沒有做到。</p>
</li>
<li><p>Dart 不是靜態型別語言。雖然我不是靜態型別的擁護者，但 Dart 語言裡許多機制，讓靜態型別顯得更適合他。靜態型別雖然還是有許多不如動態型別方便的地方，但多數人最討厭的麻煩: 冗長的型別宣告，其實根本不是靜態型別的問題。Dart 可以選擇成為一個輕巧靈活的靜態型別語言，但是 Google 把他設計成了一個混和了靜態型別和動態型別的四不像。</p>
</li>
<li><p>既然無法拋下動態型別了，那請向其他成熟的動態型別語言借鑑 : Scheme. Python. Ruby...。當知道其他類型被當作布林使用是很難避免的時候，應該給予 <strong>合理</strong> 的轉換，至少我不認為非空非零的字串/數字/陣列被當成 false 是合理的。最少最少，應該考慮一下使用者(原JS programmers)的心情和習慣。</p>
</li>
</ol>

  ]]></description><link>https://wabilin.github.io/2013-12-29-dart-boolean-type.html</link><guid isPermaLink="true">https://wabilin.github.io/2013-12-29-dart-boolean-type.html</guid><pubDate>Sun, 29 Dec 2013 00:00:00 GMT</pubDate></item><item><title><![CDATA[如何讓 Python 使用 C 的函式庫(Part 2)]]></title><description><![CDATA[
    <p>在 Part1 中我們已經成功的寫一個 C 的函式 並讓 Python 程式去使用他</p>
<p>不過其中並沒有參數的傳遞和回傳 也就是我們最需要的部分還沒有完成 現在就來看看該怎麼做~</p>
<!-- more -->
<p>在這裡我們來寫一個費氏數列的函式做示範</p>
<div>
$ f(0) = 0 $ <br>
$ f(1) = 1 $ <br>
$ f(n) = f(n-1) + f(n-2) $ <br>
</div>

<p>在 wikibooks 的教學中, 這也是第二個例子 我自己也習慣在 Hello World 之後測試費式數列, 感覺好像可以寫出費氏數列函式, 就可以做到很多事情</p>
<p>首先我們再寫一個 C 程式如下:</p>
<pre><code class="language-c">// fib.c
#include &lt;Python.h&gt;

int _fib(int n) {
    if (n &lt; 2)
        return n;
    else
        return _fib(n-1) + _fib(n-2);
}

static PyObject* fib(PyObject* self, PyObject* args) {
    int n;
    if (!PyArg_ParseTuple(args, "i", &amp;n))
        return NULL;
    return Py_BuildValue("i", _fib(n));
}

static PyMethodDef FibMethods[] = {
    {"fib", fib, METH_VARARGS, "Calculate the Fibonacci numbers."},
    {NULL, NULL, 0, NULL}
};

PyMODINIT_FUNC initfib(void) {
    (void) Py_InitModule("fib", FibMethods);
}</code></pre>
<p>首先看 <code>int _fib(int n)</code>, 這是求費氏數列的函式, 負責實際的求解運算。非常簡單的遞迴演算法, 就不多做說明了。</p>
<pre><code class="language-c">static PyObject* fib(PyObject* self, PyObject* args) {
    int n;
    if (!PyArg_ParseTuple(args, "i", &amp;n))
        return NULL;
    return Py_BuildValue("i", _fib(n));
}</code></pre>
<p>這部分是本篇的重點, 他作為和 Python 的接口, 接受參數並回傳結果 這函式長得和之前的 hello 很像, 不同的地方是 我們不再忽略 <code>args</code>, 也不直接回傳 <code>None</code> 了</p>
<p>來看看如何獲得傳進來的參數: 關鍵就在於 <code>PyArg_ParseTuple()</code> 這個函式</p>
<ul>
<li><code>args</code> =&gt; 存放參數的變數</li>
<li><code>"i"</code> =&gt; 讀入一個 integer</li>
<li><code>&amp;n</code> =&gt; 把讀進來的那個整數, 存到 n 的位置 就這麼簡單!</li>
</ul>
<p>如果我們要讀入一個字串呢?</p>
<pre><code class="language-c">char str[128];
PyArg_ParseTuple(args, "s", str);</code></pre>
<p>第一個參數是字串, 第二個參數是整數的話:</p>
<pre><code class="language-c">char str[128];
int n;
PyArg_ParseTuple(args, "si", str, &amp;n);</code></pre>
<p>詳細的使用可以參考這份文件: <a href="http://docs.python.org/dev/c-api/arg.html">http://docs.python.org/dev/c-api/arg.html</a></p>
<p>回傳結果呢?</p>
<pre><code class="language-c">return Py_BuildValue("i", _fib(n));</code></pre>
<p>因為我們必須回傳的是一個 <code>pythonObject*</code>, 而不能直接把一個 <code>int</code> 回傳 所以要先把 C 的整數轉換成包成 <code>pythonObject</code> 的整數, 而使用的就是 <code>Py_BuildValue</code> 這個函式 至於詳細的使用方法可以參考上面提過的那份文件, 在此我就只就範例來說明</p>
<p><code>return Py_BuildValue(“i”, _fib(n));</code> 這行的意義就是: 我們把 <code>_fib(n)</code>的結果轉換為 <code>pythonObject</code> 之後回傳</p>
<p>現在完成了這份 fib.c, 請把他按照上一篇的說明編譯 然後就可以在 Python 中使用他了!</p>
<pre><code class="language-python"># test_fib.py
import fib, time

def c_fib(n):
    return fib.fib(n)

def py_fib(n):
    if n &lt; 2:
        return n
    return py_fib(n-1) + py_fib(n-2)

def test_fib():
    n = int(input('N: '))
    ts = time.clock()
    print 'computing with C: '
    print c_fib(n)
    print "%.2gs" % (time.clock() - ts)

    ts = time.clock()
    print 'computing with Python: '
    print py_fib(n)
    print "%.2gs" %(time.clock() - ts)


if __name__ == '__main__':
    test_fib()</code></pre>
<p>在這份測試中, 我另外寫了一個 python 版本的求費氏數列的函式 用以比較速度</p>
<p>在我的電腦上測試的結果, 使用 C 的版本約比 Python 的版本快了 100 倍左右 可見這個做法對於解決效能瓶頸的障礙是會有幫助的!</p>
<h3 id="reference">Reference</h3>
<p><a href="http://en.wikibooks.org/wiki/Python_Programming">Python C API wikibook: python programming stackoverflow</a></p>

  ]]></description><link>https://wabilin.github.io/2013-07-20-python-c-lib-part-2.html</link><guid isPermaLink="true">https://wabilin.github.io/2013-07-20-python-c-lib-part-2.html</guid><pubDate>Sat, 20 Jul 2013 00:00:00 GMT</pubDate></item><item><title><![CDATA[如何讓 Python 使用 C 的函式庫]]></title><description><![CDATA[
    <p>從開始寫 C 到現在三年了, Python 雖然比較晚碰但也寫了一些，
不過倒是從最近才開始認真研究這個技術 : 在 Python 中呼叫 C 所寫的函式。</p>
<p>雖然知道這招很久了, 但之前一直沒有用的契機 (畢竟寫純 Python 輕鬆得多)</p>
<p>而最近因為有一個 Python Project 無法達到需要的速度，
所以打算把這招拿出來用，也就順便筆記下來了。</p>
<p>( 其實方法有不少種, 本篇主要介紹的是使用 Python C API 的方法 )</p>
<!-- more -->
<h3 id="hello-world">Hello World!</h3>
<p>不免俗的還是來個 Hello, 不過這個 Hello 的技術知識與成就感應該比很多語言的還得多</p>
<p>(Python 的 <code>print "Hello World!"</code> // 這我會了又能幹啥 XD</p>
<p>因為要讓 Python 使用 C 寫的函式庫
所以我們要先來寫一個 C File :</p>
<pre><code class="language-c">#include &lt;Python.h&gt;

static PyObject* hello(PyObject* self, PyObject* args) {
    printf("Hello! A C function called!\n");
    Py_RETURN_NONE;
}

static PyMethodDef HelloMethods[] = {
    {"hello", hello, METH_VARARGS, "A hello function."},
    {NULL, NULL, 0, NULL}
};

PyMODINIT_FUNC inithello(void) {
     (void) Py_InitModule("hello", HelloMethods);
}</code></pre>
<p>先簡單的看一下這段程式碼的意義</p>
<p>首先我們 include 了 <code>Python.h</code>, 這是 Python C API 必要的標頭檔</p>
<pre><code class="language-c">static PyObject* hello(PyObject* self, PyObject* args) {
    printf("Hello! A C function called!\n");
    Py_RETURN_NONE;
}</code></pre>
<p>在這裡, 我們寫了一個叫做 hello 的函式
他接受兩個 <code>PyObject*</code> 作為參數, 並且回傳一個 <code>PyObject*</code></p>
<p>他非常接近這樣的 Python method:</p>
<pre><code class="language-py">def hello(self, arg1, arg2...) {
  print ("Hello!")
  return None
}</code></pre>
<p>不過在 Python 中, 我們不必宣告出變數型別,
而在 C 裡面需要, 而他的型別則是 PyObject*
另外我們用一個 args 來存放零到多個參數</p>
<p>這就是在 C 中寫一個 Python method 的簡單樣貌</p>
<p>接著下一段:</p>
<pre><code class="language-c">static PyMethodDef HelloMethods[] = {
    {"hello", hello, METH_VARARGS, "A hello function."},
    {NULL, NULL, 0, NULL}
};</code></pre>
<p>我們必須告訴 pyhton, 在這個 module 中, 有那些 methods 可以用
而這個資訊被存放在 HelloMethods 這個陣列中, 陣列的每一個元素都是一個 method 的宣告,
這個宣告在 C 中的型別是一個 <code>struct (PyMethodDef)</code> , 以本例來說:</p>
<p><code>{"hello", hello, METH_VARARGS, "A hello function."}</code></p>
<p>第一項的 <code>"hello"</code> 是方法名稱 (method name)
第二項 <code>hello</code> 則是這個 method 的 C 實作函式
第三項的 <code>METH_VARARGS</code> 則是指示該如何解讀這個 method 的 flag, 不過我們先不管他
最後一項則是關於這個 method 的說明, 如同我們會寫在 python 中的 Documentation Strings</p>
<p>而 <code>{NULL, NULL, 0, NULL}</code> 則用以作為這個陣列的結尾標示</p>
<p>所以到這個部分我們已經完成了一個 method 在 C 中的實作,
並在一個變數中存入關於這個 module 的 methods 資訊</p>
<p>最後的部分則是這個 module 的初始化, 會把上面的東西放進來
不過先暫時不說明這部分</p>
<p>OK, 這個簡單的 C 檔案就這樣完成了</p>
<p>以下講解如何編譯並使用這個檔案, 每個作業系統方法小有差異, 此處以 Windows 為主。
理由是在 Linux 和 Mac OS 下本來就比較簡單, 而且這兩家的使用者平均來說自學能力比較強 不需要我贅言XD</p>
<p>如果你使用 Ubuntu :<code>sudo apt-get install python-dev</code></p>
<p>Mac OS: 因為我還買不起所以不知道, 但相信一定不難</p>
<p>Windows:
首先你必須安裝 Python,</p>
<p>當然你也必須要有 C 的編譯器 (VC++ 或 MinGW)</p>
<p>而本篇會以 MinGW 為主</p>
<p>當這些必要的準備都好了之後, 就可以來產生我們要的函式庫。
在這裡還是有兩種方法:</p>
<ol>
<li>寫一個 setup.py 腳本來 build</li>
<li>自己使用 C 編譯器來 build</li>
</ol>
<p>先說第一種方法:</p>
<p>我們先寫一個 <code>setup.py</code>:</p>
<pre><code class="language-py">from distutils.core import setup, Extension

module1 = Extension('hello', sources = ['hello.c'])

setup (name = 'PackageName',
       version = '1.0',
       description = 'This is a demo package',
       ext_modules = [module1])</code></pre>
<p>接著利用這個檔案來 build:</p>
<p>Linux: <code>python setup.py build</code></p>
<p>Windows + MinGW: <code>python setup.py build -cmingw32</code></p>
<p>在這裡你可能會遇到的錯誤:</p>
<p>1)</p>
<pre><code>‘python’ is not recognized as an internal or external command, operable program or batch file.</code></pre>
<p>這代表你還沒有安裝好 Pyhton, 或是沒有將 Python 加入到 PATH 中, 請將 python 所在目錄加到 PATH</p>
<p>2)</p>
<pre><code>error: unrecognized command line option ‘-mno-cygwin’</code></pre>
<p>請參考 <a href="http://stackoverflow.com/questions/6034390/compiling-with-cython-and-mingw-produces-gcc-error-unrecognized-command-line-o/6035864#6035864">stackoverflow</a> 上的解法, 間單的說就是去修改 <code>YourPythonDir\Lib\distutils</code> 中的 <code>cygwinccompiler.py</code></p>
<p>而第二種方法也很簡單:</p>
<pre><code>gcc -c hello.c -I/Python27/include
gcc -shared hello.o -L/Python27/libs -lpython27 -o hello.pyd</code></pre>
<p>因為我安裝的 python 版本是2.7版, 所以在此是 Python27, 如果你裝的是2.5版 那就是 Python25
另外如果有更改安裝路徑的話也請自行修改指令, 假設你 python 裝在 <code>D:/Python27</code>
那第一行就改成 <code>gcc -c hello.c -ID:/Python27/include</code></p>
<p>無論你用上面哪一種方法 你都可以得到一個 hello.pyd 的檔案</p>
<p>這時我們再來寫一個 python 程式來使用他, 請將這個 Python 程式放在和 <code>hello.pyd</code> 同一個資料夾</p>
<pre><code class="language-py">import hello

hello.hello()</code></pre>
<p>現在 hello 被我們作為一個 module 使用了!
我們呼叫 hello module 中的 hello method
他會輸出:
<code>Hello! A C function called!</code></p>
<p>成功!</p>
<h3 id="reference">Reference</h3>
<ul>
<li><a href="http://docs.python.org/2/c-api/">Python C API</a></li>
<li><a href="http://en.wikibooks.org/wiki/Python_Programming">wikibook: python programming</a></li>
<li><a href="http://stackoverflow.com/">stackoverflow</a></li>
</ul>

  ]]></description><link>https://wabilin.github.io/2013-07-18-python-c-lib.html</link><guid isPermaLink="true">https://wabilin.github.io/2013-07-18-python-c-lib.html</guid><pubDate>Thu, 18 Jul 2013 00:00:00 GMT</pubDate></item><item><title><![CDATA[C++11 Range-based for]]></title><description><![CDATA[
    <p>本篇搬移自舊部落格 (2013年4月)</p>
<p>使用過 Python, C# 等語言的 <code>for</code> (<code>foreach</code>) 之後，
我就肖想這個功能很久了，現在 C++11 終於也有了這種形式的 <code>for</code> 迴圈！</p>
<h3 id="overview">overview</h3>
<pre><code class="language-cpp">int a[] = {4, 5, 6};
for (int e : a)
  printf("%d ", e);

/* output: 4 5 6 */</code></pre>
<!-- more -->
<h3 id="introduction">introduction</h3>
<p>又是一個我一直想很要的功能XD</p>
<p>在 Ruby, Python, C# 等語言中 用這種 range-based iteration 是方便而安全的作法，
而且這種概念其實並不算是新穎的奇招，至少在 Ada 和 Fortran 中也有相似的語法。</p>
<p>要說明它的好處，就先來批鬥一下 C/C++ 與其他 C-based Language 的 for 迴圈寫法有什麼缺點。
(* 包含個人主觀意見)</p>
<p>以一個簡單的陣列複製為例，在 C 中如果不想用 <code>memcpy</code> 之類的函式 通常會這樣做:</p>
<pre><code class="language-c">#define SIZE 10

int a[SIZE] = {...};
int b[SIZE];
for (size_t i = 0; i &lt; SIZE; ++i)
  b[i] = a[i];</code></pre>
<p>這種語法有以下缺點:</p>
<h4 id="1-觀感問題-奇摸子問題">1. 觀感問題 (奇摸子問題)</h4>
<p><code>for</code> 通常使用在和範圍相關的迴圈上，
例如遍歷一個陣列，或是由最小值到最大值之類的的計算。</p>
<p>把 for 用在和範圍無關的迴圈上，通常不是件好事 例如:</p>
<pre><code class="language-c">for (; something ;) { ... }</code></pre>
<p>用 <code>while</code> 取代會有更清楚的語意。</p>
<p>但是用來做範圍相關迭代的 <code>for</code>, 本身卻沒有提供和範圍相關的限制與迭代方法，
而完全只是一個 <code>while</code> 的語法糖。</p>
<pre><code class="language-c">for (a; b; c) { ... }</code></pre>
<p>和</p>
<pre><code class="language-c">a;
while (b) { ...; c;}</code></pre>
<p>完全相等</p>
<p>也就是這個語言中就算完全沒有 <code>for</code>，能做的事情也不會減少。
雖然可讀性較佳，卻又有種多餘的感覺。</p>
<h4 id="2-安全問題">2. 安全問題</h4>
<p>因為語法本身沒有包含對範圍的限制 仰賴程式設計師自己的設計
常成為蟲蟲的溫床 如常見的新手錯誤</p>
<pre><code class="language-c">int a[10];
for (int i = 0 ; i &lt;= 10 ; ++i) {...}</code></pre>
<p>除了新手以外的人 也難免偶爾會老馬按錯鍵 浪費一堆時間 Debug (連bebug都沒有就更慘了)</p>
<h4 id="3-麻煩問題">3. 麻煩問題</h4>
<p>你可以說上面的問題，完全只是低級的錯誤，因為有經驗的人通常會這樣寫:</p>
<pre><code class="language-c">#define SIZE 10

for (size_t i = 0; i &lt; SIZE; ++i) { ... }</code></pre>
<p>當然我又會挑剔 使用 <code>#define</code> 所造成的問題, 所以改成:</p>
<pre><code class="language-cpp">static const size_t SIZE = 10;
for (size_t i = 0; i &lt; SIZE; ++i) { ... }</code></pre>
<p>這樣寫是以前的好寫法 大部分的問題都解決了，
不過仍然存在一個問題: 第一行實在很長很麻煩！</p>
<p>程式設計師天性懶散。怕麻煩是天經地義的事情 :)</p>
<p>我們願意忍受麻煩A，通常是為了避免更嚴重的麻煩B。
如果可以兩者都扔掉，絕對不會想承受其中任何一個。</p>
<p>一開始也看過大概的用法了，現在來看一下其定義[1]吧:</p>
<pre><code class="language-cpp">for ( for-range-declaration : expression ) statement</code></pre>
<p>等同於</p>
<pre><code class="language-cpp">{
  auto &amp;&amp; __range = ( expression );
  for (auto __begin = begin-expr, __end = end-expr;
       __begin != __end; ++__begin ) {
    for-range-declaration = *__begin;
    statement
  }
}</code></pre>
<p>其中 <code>expression</code>, <code>begin-expr</code> 和 <code>end-expr</code> 的型態為 <code>_RangeT</code></p>
<p>如果 <code>_RangeT</code> 是陣列的話,</p>
<pre><code>begin-expr = __range, end-expr = __range + __bound</code></pre>
<p>否則</p>
<pre><code>begin-expr = begin(__range), end-expr = end(__range),</code></pre>
<p>在尋找符合的 <code>begin()</code>, <code>end()</code>時
也會看到 namespace std 中的 <code>std::begin()</code> 和 <code>std::end()</code></p>
<p>(我翻譯的能力有限 要看明確的定義還是請翻一下原文</p>
<p>所以 range-based for 可以用的地方分為兩類:</p>
<ol>
<li>型態及長度明確之 C++ 陣列</li>
<li>其他有提供迭代方法的類別</li>
</ol>
<p>以下分別解釋:</p>
<p>型態及長度明確之 C++ 陣列:</p>
<p>大部分的時候 會感覺C++ 的陣列和指標用起來完全一樣
但實際上還是有差別的
而能夠使用 range-based for 的 只有真正最標準的 C++ 陣列 例如:</p>
<pre><code class="language-cpp">const char str[] = "1234";
int ary[10];
MyType m_ary[] = {};

for (char c : str) { }   // OK
for (int e : ary) { }    // OK
for (auto m : m_ary) { } // OK</code></pre>
<p>而以下我們很習慣把指標當成陣列的用法 卻是不能用 range-based for 的:</p>
<pre><code class="language-cpp">void foo(int a1[], int* a2) {
  const char* str = "A pointer to C string";

  for (int a : a1) {}    // error
  for (int a : a2) {}    // error
  for (char c : str) {}  // error
}</code></pre>
<p>因為指標型態並沒有記錄陣列大小，所以無法使用是理所當然的。
不過這種「大部分時間用起來一樣，卻有時候不一樣」的東西真的有點惱人。
而且 C++ 陣列因為相容 C 雖然有幫你記下大小，但並不確保相關的安全性。</p>
<p>因此我比較推薦在 C++ 中 盡量以 <code>std::vector</code> 或 <code>std::array</code> 取代傳統陣列，
除非你的編譯器對 <code>vector</code> 效能實作得非常差 (正常來說和陣列的效能差距應該是很小的)，
或是你對效能極度計較，不然多數時候沒有使用傳統陣列之必要。</p>
<p>別忘了</p>
<blockquote>
<p>Premature optimization is the root of all evil.</p>
</blockquote>
<p>其他有提供迭代方法的類別:</p>
<p>依照上面提過的定義，如果要把 range-based for 用在某類別 T</p>
<p>最少要有: 產生 iterator 的 <code>begin(T)</code>. <code>end(T)</code> 以及該 iterator 的 <code>operator ++</code>(prefix ver.)
依照 C++ <code>&lt;iterator&gt;</code> 中定義的 <code>std::begin()</code> 和 <code>std:: end()</code> [2]
如果有定義 <code>T.begin()</code> 和 <code>T.end()</code> 的話也可行 (應該也是比較好的做法)</p>
<p>這包括了所有有實作 iteration 功能的 STL 類別, 如:</p>
<p>vector, array, string,  deque, list, forward_list,
map, unordered_map, set, unordered_set...</p>
<p>一個敷衍用的範例 (反正每個用法都差不多) :</p>
<pre><code class="language-cpp">std::vector&lt;int&gt; v = {1, 2, 3, 4, 5};

for (int e : v)
  printf("%d", e);</code></pre>
<p>相較於</p>
<pre><code class="language-cpp">for (std::vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); ++it)
  printf("%d", *it);</code></pre>
<p>少打了很多字，真是開心 :)</p>
<p>此外你也可以自己設計相容的類別。
( 本來我想順便寫怎麼做 不過怕這篇會變太長 而且又不知道要拖到什麼時候了</p>
<p>另外這種 <code>for</code> 常常搭配 <code>auto</code> 一起使用, 這個關鍵字之前也介紹過了
結合兩者之後更朝懶人 C++ 邁進了一大步</p>
<pre><code class="language-cpp">const vector&lt;MySuperCoolType&gt; cv = {};
vector&lt;MySuperCoolType&gt; vv = {};


for (auto e : cv)
  cout &lt;&lt; e;

for (auto&amp; e : vv)  // 如果要更改內容的話 可以用auto&amp;
  e = MySuperCoolType();</code></pre>
<h3 id="comment">comment</h3>
<p>我認為這是一個非常良好的改進。</p>
<p>多數該支援的標準函式庫也都支援了，用起來非常方便。</p>
<p>可以少打很多字 愉☆悅~</p>
<h3 id="chat">chat</h3>
<p>C++ 中本來也有一個叫 <code>for_each</code> 的函式，
不過做法比較接近 functional language 中常見的 map 函式。</p>
<p>用法大略如下:</p>
<pre><code class="language-cpp">void foo(int&amp; n) {
  n = n * 2;
}

int main(){
  vector&lt;int&gt; v = {0,1,2,3};
  for_each (v.begin(), v.end(), foo);

  for(int e : v)
    printf(" %d", e);
  // output: 0 2 4 6
}</code></pre>
<p>通常是本來就已經有適合的函式可以用 才會用 for_each
不然的話要用它來取代 for 迴圈其實是件更麻煩的事情</p>
<h3 id="reference">Reference</h3>
<p>[1] <a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2009/n2930.html">http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2009/n2930.html</a></p>
<p>[2] <a href="http://en.cppreference.com/w/cpp/iterator">http://en.cppreference.com/w/cpp/iterator</a></p>

  ]]></description><link>https://wabilin.github.io/2013-04-13-cpp11-range-based-for.html</link><guid isPermaLink="true">https://wabilin.github.io/2013-04-13-cpp11-range-based-for.html</guid><pubDate>Sat, 13 Apr 2013 00:00:00 GMT</pubDate></item><item><title><![CDATA[C++11 auto-typed variables]]></title><description><![CDATA[
    <p>本篇搬移自舊部落格 (2013年4月)</p>
<p>型別推導在動態語言中是必然的，而傳統的靜態型別語言則多數要求事先宣告變數型別，
但最近的靜態型別語言也越來越盛行型別推導 如 Go、C#、Haskell 等語言都支援靜態的型別推導。</p>
<p>現在C++ 也開始支援這個功能了。</p>
<h2 id="overview">overview</h2>
<pre><code class="language-cpp">auto v = something;
// 我們在宣告變數 v 時,可以不自己指定 v 的型別，
// 而使用關鍵字auto，看 something 來決定的 v 型別</code></pre>
<!-- more -->

<h2 id="introduction">introduction</h2>
<p>型別推導並不是什麼艱澀難懂的概念，以動態語言 Python 為例，一個整數的變數會這樣寫：</p>
<pre><code class="language-python">a = 0</code></pre>
<p>因為 <code>0</code> 是整數，所以執行到這行的時候，<code>a</code>就會是一個整數變數</p>
<p>而在靜態型別的 C 和以前的 C++ 中，所有變數都必須先宣告型別:</p>
<pre><code class="language-cpp">int a = 0;</code></pre>
<p>然而在靜態型別的語言中使用型別推導並非不可行的，以前大部分不支援應該是為了編譯的速度。
但隨著電腦效能越來越好，大家都想要程式寫得輕鬆，靜態型別的語言也開始支援了。</p>
<p>關於其他語言的做法，就留到文末來欣賞，現在直接來看看 C++11 怎麼玩:</p>
<pre><code class="language-cpp">auto i = 1;
double pi = 3.14;
auto f = pi + 5;</code></pre>
<p>首先 <code>i</code> 這個變數，因為等號右方的 <code>1</code> 是 <code>int</code>，所以 <code>i</code> 會是一個 <code>int</code> 變數，
而變數 <code>f</code> 因為是 <code>pi(double) + 5(int)</code> 的結果，所以必然是一個 <code>double</code>。
這些都是在編譯階段就可以確定的，所以使用 <code>auto</code> 變數並不會有像動態語言中，型別推導造成執行時其額外成本的問題。</p>
<p>另外一點不同的是，動態語言中變數的型別大多是可以改變的。
但在靜態語言中，就算使用 <code>auto</code> 這種方法，也是在宣告後就固定型別，
而且一定要給定初始值（不然怎麼推導=.=）。</p>
<pre><code class="language-cpp">auto a = 3.14f; // OK, float
auto b(4);      // OK, int

auto c; // error
b = std::string("xd"); // error, b must be a int</code></pre>
<p>不過看到這裡，可能會認為這個功能沒有什麼必要性</p>
<pre><code class="language-cpp">auto a = 1;
int  b = 0;</code></pre>
<p>在這裡實在沒有什麼理由懶得自己去判斷 <code>a</code> 的型別，像 <code>b</code> 這樣寫還可以少打一個字</p>
<p>然而在使用 STL 和各種 library 以及自訂型別的時候，這個功能就顯得十分有用了。
因為這些型別名稱往往很長，有些甚至你要確認他是什麼型別也很麻煩。</p>
<p>舉一個很常見的例子：</p>
<pre><code class="language-cpp">#include &lt;vector&gt;

class LoveLive{
 // somethings..
 void foo() const;
};

int main() {
  using std::vector;
  vector&lt;LoveLive&gt; lives;
  for (vector&lt;LoveLive&gt;::const_iterator it = lives.cbegin();
       it &lt; lives.cend() ;
       ++it) {
    it-&gt;foo();
  }
}</code></pre>
<p>這是我之前最痛恨 STL 的其中一點----常常只是做很簡單的事情，卻因為各種落落長的名稱，
而寫成超長的一行，甚至得拆成醜醜的好幾行。</p>
<p>然而現在有了 <code>auto</code> 我可以這樣寫：</p>
<pre><code class="language-cpp">for (auto it = lives.cbegin(); it &lt; lives.cend() ; ++it) {
  it-&gt;foo();
}</code></pre>
<p>少打了許多字，也不用怕忘記 <code>iterator</code> 怎麼拼 (當然這個常用應該不會忘，但有些比較少用的就要一直查了..)</p>
<p> (註：以 <code>for</code> 迴圈來說，這個例子還有更簡潔的寫法，之後在他篇會介紹</p>
<p>就本例而言，可以感受到 <code>auto</code> 帶來的一點小便利，讓我們再看看沒有它的話我們會很痛苦的例子：</p>
<pre><code class="language-cpp">// Code from: http://en.wikipedia.org/wiki/C%2B%2B11
#include &lt;random&gt;
#include &lt;functional&gt;

std::uniform_int_distribution&lt;int&gt; distribution(0, 99);
std::mt19937 engine; // Mersenne twister MT19937
auto generator = std::bind(distribution, engine);

// Generate a uniform integral variate between 0 and 99.
int random = generator();</code></pre>
<p>這是在 C++11 中提供的一種產生亂數的新方式。
我們看到 <code>generator</code> 並未指定型別而使用了 <code>auto</code> 來做型別推導，
因為 <code>std::bind</code> 會把 <code>distribution</code> 和 <code>engine</code> 打包成某種可以被存在 <code>std::function</code> 的物件</p>
<p>雖然我們可以大概知道那是怎樣的形態，但絕對不會明確的想出來，
就算我們以人腦推出來了，也不會想花力氣打進去..</p>
<p>如果沒有 <code>auto</code> 可用，或是你很熱血的想把這玩意的型別打上去</p>
<p>好吧，嗯......
你會寫成這樣：</p>
<pre><code class="language-cpp">std::_Bind
  &lt;std::uniform_int_distribution&lt;int&gt;(
     std::mersenne_twister_engine&lt;
       long unsigned int, 32ul, 624ul, 397ul,
       31ul, 2567483615ul, 11ul, 4294967295ul,
       7ul, 2636928640ul, 15ul, 4022730752ul,
       18ul, 1812433253ul
       &gt;)&gt; generator = std::bind(distribution, engine);</code></pre>
<p>我相信沒有人可以這麼勤勞，無論是寫或看..</p>
<p>所以，<code>auto</code> 的使用，不但可以減少打字時間，增近開發速度 (講難聽點就是偷懶)
在某些場合更是必要之手段</p>
<p>另外 <code>auto</code> 也可以配合關鍵 pointer 和 reference 使用：</p>
<pre><code class="language-cpp">int a = 0; // int
auto  b = a; // int
auto&amp; r = a; // int&amp;

auto  p1 = &amp;a; // int*
auto* p2 = &amp;a; // int*

auto c = a, *d = &amp;a // OK
auto e = a, f = &amp;a  // error</code></pre>
<h2 id="comment">comment</h2>
<p>除了有必須使用的地方，必須把這招學起來以外。
也建議在其他適當場合使用 <code>auto</code> ，省力又簡潔。</p>
<p>不過也不宜濫用( 把 <code>int</code> 等基本型別也寫成 <code>auto</code> )，會讓可讀性下降，
如果推導出來地型別和你預期的不一樣而產生bug也只能說是自作自受..</p>
<p>這應該算是一個實用價值很高的新功能。</p>
<p>另外 <code>auto</code> 這個關鍵字的其他使用場合，以及與他有點關係的 <code>decltype</code> 會在其他篇介紹</p>
<h2 id="chat">chat</h2>
<p>在其他靜態語言中，也有型別推導，
C# 可以有靜態和動態的型別推導，其中靜態型別推導的用法和本篇C++11的用法很相似，
不過 C# 使用的關鍵字是 <code>var</code></p>
<p>Go 語言有兩種寫法：</p>
<pre><code class="language-go">var x, y, z int = 1, 2, 3
var a, b, c = true, false, "no!"
i := 0</code></pre>
<p>其中 <code>x, y, z</code> 是由 programmer 指定型別 <code>int</code>，
而 <code>a, b, c</code> 則是藉由型別推導分別得到 <code>bool, bool, string</code> 型別，
變數 <code>i</code> 則使用了 <code>:=</code> 省略關鍵字 <code>var</code>，並推導得到型別 <code>int</code></p>
<p>而 Haskell 的型別就更有趣了，不過在這裡講下去，篇幅大概就要比原本的主題還多了:P</p>
<p>有興趣的話請自行研究囉</p>
<h2 id="reference">Reference</h2>
<ul>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1984.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1984.pdf</a></li>
<li><a href="http://www.cprogramming.com/c++11/c++11-auto-decltype-return-value-after-function.html">http://www.cprogramming.com/c++11/c++11-auto-decltype-return-value-after-function.html</a></li>
<li><a href="http://zh.wikipedia.org/">http://zh.wikipedia.org</a></li>
</ul>

  ]]></description><link>https://wabilin.github.io/2013-02-14-cpp11-auto-typed-variables.html</link><guid isPermaLink="true">https://wabilin.github.io/2013-02-14-cpp11-auto-typed-variables.html</guid><pubDate>Thu, 14 Feb 2013 00:00:00 GMT</pubDate></item></channel></rss>