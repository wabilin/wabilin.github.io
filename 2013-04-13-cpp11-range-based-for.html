<!DOCTYPE html><html lang="en"><head>
    <meta name="author" content="wabilin">

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Explosion! | C++11 Range-based for</title>

    <link rel="stylesheet" type="text/css" href="./style.css">
    <link rel="icon" type="image/svg+xml" href="./favicon.svg">
    <link rel="alternate" type="application/rss+xml" href="./feed.xml">

    <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.0.0/build/styles/github.min.css">
    <script>
      function onHighlightLoad() {
        hljs.initHighlightingOnLoad();
      }
    </script>
    <script defer="" onload="onHighlightLoad()" src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.0.0/build/highlight.min.js">
    </script>
  <meta property="og:type" content="article"><meta property="og:title" content="C++11 Range-based for"><meta property="article:published_time" content="2013-04-13T00:00:00.000Z"><meta property="article:tag" content="cpp"><meta property="article:license" content="cc0"></head>

  <body>
    <div class="post">
      <header class="blog-title">
        <h1>
          <a href="./">(∩ ◕_▩ )⊃━☆ Explosion!!</a>
        </h1>
      </header>

      <section id="main" class="post-section"><hgroup><h2>C++11 Range-based for</h2><h6>2013-04-13</h6></hgroup> <article>
    <p>本篇搬移自舊部落格 (2013年4月)</p>
<p>使用過 Python, C# 等語言的 <code>for</code> (<code>foreach</code>) 之後，
我就肖想這個功能很久了，現在 C++11 終於也有了這種形式的 <code>for</code> 迴圈！</p>
<h3 id="overview">overview</h3>
<pre><code class="language-cpp">int a[] = {4, 5, 6};
for (int e : a)
  printf("%d ", e);

/* output: 4 5 6 */</code></pre>
<!-- more -->
<h3 id="introduction">introduction</h3>
<p>又是一個我一直想很要的功能XD</p>
<p>在 Ruby, Python, C# 等語言中 用這種 range-based iteration 是方便而安全的作法，
而且這種概念其實並不算是新穎的奇招，至少在 Ada 和 Fortran 中也有相似的語法。</p>
<p>要說明它的好處，就先來批鬥一下 C/C++ 與其他 C-based Language 的 for 迴圈寫法有什麼缺點。
(* 包含個人主觀意見)</p>
<p>以一個簡單的陣列複製為例，在 C 中如果不想用 <code>memcpy</code> 之類的函式 通常會這樣做:</p>
<pre><code class="language-c">#define SIZE 10

int a[SIZE] = {...};
int b[SIZE];
for (size_t i = 0; i &lt; SIZE; ++i)
  b[i] = a[i];</code></pre>
<p>這種語法有以下缺點:</p>
<h4 id="1-觀感問題-奇摸子問題">1. 觀感問題 (奇摸子問題)</h4>
<p><code>for</code> 通常使用在和範圍相關的迴圈上，
例如遍歷一個陣列，或是由最小值到最大值之類的的計算。</p>
<p>把 for 用在和範圍無關的迴圈上，通常不是件好事 例如:</p>
<pre><code class="language-c">for (; something ;) { ... }</code></pre>
<p>用 <code>while</code> 取代會有更清楚的語意。</p>
<p>但是用來做範圍相關迭代的 <code>for</code>, 本身卻沒有提供和範圍相關的限制與迭代方法，
而完全只是一個 <code>while</code> 的語法糖。</p>
<pre><code class="language-c">for (a; b; c) { ... }</code></pre>
<p>和</p>
<pre><code class="language-c">a;
while (b) { ...; c;}</code></pre>
<p>完全相等</p>
<p>也就是這個語言中就算完全沒有 <code>for</code>，能做的事情也不會減少。
雖然可讀性較佳，卻又有種多餘的感覺。</p>
<h4 id="2-安全問題">2. 安全問題</h4>
<p>因為語法本身沒有包含對範圍的限制 仰賴程式設計師自己的設計
常成為蟲蟲的溫床 如常見的新手錯誤</p>
<pre><code class="language-c">int a[10];
for (int i = 0 ; i &lt;= 10 ; ++i) {...}</code></pre>
<p>除了新手以外的人 也難免偶爾會老馬按錯鍵 浪費一堆時間 Debug (連bebug都沒有就更慘了)</p>
<h4 id="3-麻煩問題">3. 麻煩問題</h4>
<p>你可以說上面的問題，完全只是低級的錯誤，因為有經驗的人通常會這樣寫:</p>
<pre><code class="language-c">#define SIZE 10

for (size_t i = 0; i &lt; SIZE; ++i) { ... }</code></pre>
<p>當然我又會挑剔 使用 <code>#define</code> 所造成的問題, 所以改成:</p>
<pre><code class="language-cpp">static const size_t SIZE = 10;
for (size_t i = 0; i &lt; SIZE; ++i) { ... }</code></pre>
<p>這樣寫是以前的好寫法 大部分的問題都解決了，
不過仍然存在一個問題: 第一行實在很長很麻煩！</p>
<p>程式設計師天性懶散。怕麻煩是天經地義的事情 :)</p>
<p>我們願意忍受麻煩A，通常是為了避免更嚴重的麻煩B。
如果可以兩者都扔掉，絕對不會想承受其中任何一個。</p>
<p>一開始也看過大概的用法了，現在來看一下其定義[1]吧:</p>
<pre><code class="language-cpp">for ( for-range-declaration : expression ) statement</code></pre>
<p>等同於</p>
<pre><code class="language-cpp">{
  auto &amp;&amp; __range = ( expression );
  for (auto __begin = begin-expr, __end = end-expr;
       __begin != __end; ++__begin ) {
    for-range-declaration = *__begin;
    statement
  }
}</code></pre>
<p>其中 <code>expression</code>, <code>begin-expr</code> 和 <code>end-expr</code> 的型態為 <code>_RangeT</code></p>
<p>如果 <code>_RangeT</code> 是陣列的話,</p>
<pre><code>begin-expr = __range, end-expr = __range + __bound</code></pre>
<p>否則</p>
<pre><code>begin-expr = begin(__range), end-expr = end(__range),</code></pre>
<p>在尋找符合的 <code>begin()</code>, <code>end()</code>時
也會看到 namespace std 中的 <code>std::begin()</code> 和 <code>std::end()</code></p>
<p>(我翻譯的能力有限 要看明確的定義還是請翻一下原文</p>
<p>所以 range-based for 可以用的地方分為兩類:</p>
<ol>
<li>型態及長度明確之 C++ 陣列</li>
<li>其他有提供迭代方法的類別</li>
</ol>
<p>以下分別解釋:</p>
<p>型態及長度明確之 C++ 陣列:</p>
<p>大部分的時候 會感覺C++ 的陣列和指標用起來完全一樣
但實際上還是有差別的
而能夠使用 range-based for 的 只有真正最標準的 C++ 陣列 例如:</p>
<pre><code class="language-cpp">const char str[] = "1234";
int ary[10];
MyType m_ary[] = {};

for (char c : str) { }   // OK
for (int e : ary) { }    // OK
for (auto m : m_ary) { } // OK</code></pre>
<p>而以下我們很習慣把指標當成陣列的用法 卻是不能用 range-based for 的:</p>
<pre><code class="language-cpp">void foo(int a1[], int* a2) {
  const char* str = "A pointer to C string";

  for (int a : a1) {}    // error
  for (int a : a2) {}    // error
  for (char c : str) {}  // error
}</code></pre>
<p>因為指標型態並沒有記錄陣列大小，所以無法使用是理所當然的。
不過這種「大部分時間用起來一樣，卻有時候不一樣」的東西真的有點惱人。
而且 C++ 陣列因為相容 C 雖然有幫你記下大小，但並不確保相關的安全性。</p>
<p>因此我比較推薦在 C++ 中 盡量以 <code>std::vector</code> 或 <code>std::array</code> 取代傳統陣列，
除非你的編譯器對 <code>vector</code> 效能實作得非常差 (正常來說和陣列的效能差距應該是很小的)，
或是你對效能極度計較，不然多數時候沒有使用傳統陣列之必要。</p>
<p>別忘了</p>
<blockquote>
<p>Premature optimization is the root of all evil.</p>
</blockquote>
<p>其他有提供迭代方法的類別:</p>
<p>依照上面提過的定義，如果要把 range-based for 用在某類別 T</p>
<p>最少要有: 產生 iterator 的 <code>begin(T)</code>. <code>end(T)</code> 以及該 iterator 的 <code>operator ++</code>(prefix ver.)
依照 C++ <code>&lt;iterator&gt;</code> 中定義的 <code>std::begin()</code> 和 <code>std:: end()</code> [2]
如果有定義 <code>T.begin()</code> 和 <code>T.end()</code> 的話也可行 (應該也是比較好的做法)</p>
<p>這包括了所有有實作 iteration 功能的 STL 類別, 如:</p>
<p>vector, array, string,  deque, list, forward_list,
map, unordered_map, set, unordered_set...</p>
<p>一個敷衍用的範例 (反正每個用法都差不多) :</p>
<pre><code class="language-cpp">std::vector&lt;int&gt; v = {1, 2, 3, 4, 5};

for (int e : v)
  printf("%d", e);</code></pre>
<p>相較於</p>
<pre><code class="language-cpp">for (std::vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); ++it)
  printf("%d", *it);</code></pre>
<p>少打了很多字，真是開心 :)</p>
<p>此外你也可以自己設計相容的類別。
( 本來我想順便寫怎麼做 不過怕這篇會變太長 而且又不知道要拖到什麼時候了</p>
<p>另外這種 <code>for</code> 常常搭配 <code>auto</code> 一起使用, 這個關鍵字之前也介紹過了
結合兩者之後更朝懶人 C++ 邁進了一大步</p>
<pre><code class="language-cpp">const vector&lt;MySuperCoolType&gt; cv = {};
vector&lt;MySuperCoolType&gt; vv = {};


for (auto e : cv)
  cout &lt;&lt; e;

for (auto&amp; e : vv)  // 如果要更改內容的話 可以用auto&amp;
  e = MySuperCoolType();</code></pre>
<h3 id="comment">comment</h3>
<p>我認為這是一個非常良好的改進。</p>
<p>多數該支援的標準函式庫也都支援了，用起來非常方便。</p>
<p>可以少打很多字 愉☆悅~</p>
<h3 id="chat">chat</h3>
<p>C++ 中本來也有一個叫 <code>for_each</code> 的函式，
不過做法比較接近 functional language 中常見的 map 函式。</p>
<p>用法大略如下:</p>
<pre><code class="language-cpp">void foo(int&amp; n) {
  n = n * 2;
}

int main(){
  vector&lt;int&gt; v = {0,1,2,3};
  for_each (v.begin(), v.end(), foo);

  for(int e : v)
    printf(" %d", e);
  // output: 0 2 4 6
}</code></pre>
<p>通常是本來就已經有適合的函式可以用 才會用 for_each
不然的話要用它來取代 for 迴圈其實是件更麻煩的事情</p>
<h3 id="reference">Reference</h3>
<p>[1] <a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2009/n2930.html">http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2009/n2930.html</a></p>
<p>[2] <a href="http://en.cppreference.com/w/cpp/iterator">http://en.cppreference.com/w/cpp/iterator</a></p>

  </article><div class="license-area">
  <a rel="license" href="http://creativecommons.org/publicdomain/zero/1.0/">
    <img src="http://i.creativecommons.org/p/zero/1.0/88x31.png" style="border-style: none;" alt="CC0">
  </a>
  <br>
  To the extent possible under law,<br>
  <a rel="dct:publisher" href="https://github.com/wabilin">
    <span property="dct:title">wabilin</span></a>
  has waived all copyright and related or neighboring rights to
  this work.
</div></section>

      <footer class="footer-back">
        <a href="./">← back</a>
      </footer>
    </div>

    <footer class="page-footer">
      Subscribe via
      <a href="https://wabilin.github.io/feed.xml">
        RSS
      </a>.
    </footer>
  

</body></html>